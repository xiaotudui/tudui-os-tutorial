## 线程切换

### 几个概念

#### 1、用户态和内核态。

总的来说，用户态很卑微，只能访问受限的内存，只能运行部分指令集，比如磁盘读写是不行的。

内核态，可以访问所有的资源，运行所有指令集，不受限。

这样，主要是为了防止任意程序对其他程序的破坏。

其实现，主要是通过控制寄存器中的 **模式位** 来进行标注。

如果说用户态想要进入内核态（比如，要读写磁盘），可以通过 系统调用、中断、异常。

#### 2、线程、进程、用户态、内核态

在这一块就比较绕了。

用户态中，可以分为：用户态线程、用户态进程

内核态中：用户态进程（线程）

也就是说，在内核态中是不区分进程与线程的，你想想，内核态直接就分配 CPU 资源了。

### 线程切换的过程

#### 1、从用户态线程 到 内核态线程

首先，用户栈存储了用户态线程运行的状态。

当它遇到中断、系统调用的时候，如下图的 INT 指令的时候，如上文所提及的，它会进入到内核态。

（比如我们此时想要做一些只能内核态才能做的事情，会调用中断 INT，会让其进入内核态）

![](https://pic.imgdb.cn/item/5ea6f6f7c2a9a83be5db2ede.png)

此时，内核态中的内核栈，记录了一些信息：

SS，SP：用户栈的起始位置

EFLAGS：用户栈的标志寄存器

PC、CS：返回时，用户栈中的返回地址

![](https://pic.imgdb.cn/item/5ea7c8c6c2a9a83be5a2c8e3.png)

#### 2、内核栈之间切换

比如此时，当内核态中的此线程的时间片被用完，或者存在被阻塞，就需要切换内核态线程。

这个时候就需要进行内核栈之间的切换。

如何切换内核栈呢？我们肯定得知道另一个内核栈的位置，另一个内核栈也代表着另一个内核态线程。

![](https://pic.imgdb.cn/item/5ea7df62c2a9a83be5b95caa.png)

**我们看下上面的图，每个内核栈中有个 PCB（Process Control Block），是控制每个进程的信息。**

**比如我们现在在AB的内核栈，我们想要切换到A内核态。**

**你会发现AB内核栈有个箭头指向A内核栈。这个箭头的作用就相当于下文讲的 TCB。**

这个时候就轮到 TCB （线程/任务控制块，Task/Thread Control Block）出场了。

在内核中，也可以将内核态线程称为任务。

TCB 记录了内核态线程的一些信息，所在位置。所以可以猜测，TCB 在内核态中是唯一且可见的。

所以我们就可以访问 TCB 获取另一个内核栈的位置。

#### 3、内存切换



### 参考

《Linux 0.11 完全注释》

* 5.7 Linux 进程控制
* 5.8 Linux 系统中堆栈的使用方法